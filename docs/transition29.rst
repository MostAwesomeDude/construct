=================
Transition to 2.9
=================

Overall
=======

Construct 2.9 adds an experimental feature: compiling user made constructs into faster (but less feature-rich) code. If you are familiar with Kaitai Struct, an alternative framework to Construct, Kaitai compiles its own yaml-based language schemas into Python modules. Construct on the other hand, defines schemas in Python and compiles it into also a Python module. Once you define a construct, you can use it to parse and build strings without compilation. Compilation has only one purpose: performance. Compiled constructs cannot do anything more than original constructs, in fact, they have restricted capabilities (some classes do not compile, or compile only under certain circumstances).

Requirements
------------

Compilation feature requires Construct 2.9 and Python 3.3. More importantly, you should manually check the generated code for correctness and have a test suite of your own. Construct aims to be reliable, but there is inherent risk in using experimental features.

Compiling schemas
===================

Every construct (even those that do not compile) has a parameter-less `compile` method that returns also a construct (instance of Compiled class). Note that compiling takes a substantial amount of time (compared to parsing a single blob) so it may be a good idea to compile something that is used for processing giga-sized data or multiple blobs of data, but should not be overused.
That compiled instance has `parse` and `build` methods like any other class.

>>> st = Struct("num" / Byte)
>>> st.parse(b"\x01")
Container(num=1)
>>> st2 = st.compile()
>>> st2.parse(b"\x01")
???

Compiled instance has a unique `source` field that holds the generated code as string and also has a unique method `tofile` that saves the generated source code to a file, for your inspection for example. You can also import such a module from a Python script.

>>> st2.source
"... schema code ..."
>>> st2.tofile("schema1.py")
>>> import schema1

Motivation
===========

The code generated by compiler and core classes have essentially same functionality, but there is a noticable difference in performance. This chapter explains what exactly makes that difference.
